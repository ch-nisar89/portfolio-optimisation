---
title: "Coursework1"
author: "Nisar Ahmed"
date: "2024-02-24"
output: pdf_document
---

# Part 1 - Optimization of the Portfolio using GA

### Checking and installing necessary packages and libraries
Ensuring all necessary R packages are installed and loaded for portfolio analysis and optimization.
```{r include=FALSE}
necessary_packages <- c("GA", "quantmod", "TTR", "xts", "zoo", "PerformanceAnalytics", "dplyr")
for(package in necessary_packages) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
}

library(GA)
library(quantmod)
library(xts)
library(zoo)
library(TTR)
library(PerformanceAnalytics)
library(dplyr)
library(ggplot2)
```


## Part 1(a): Selection of Assets
Selecting 10 diverse assets from different sectors to construct a well-rounded portfolio.
This diversity aims to mitigate risk by spreading investments across diff market behaviors, including tech, healthcare, and energy sectors.
```{r}
my_assets <- c("AAPL", "PFE", "BAC", "TSLA", "PG", "XOM", "NEE", "BA", "DD", "SPG")
```


## Part 1(b): Data Retrieval and Pre-processing 
Fetching historical price data for the selected assets from 2020 to 2022.

### Why COVID-19 Period?
The three-year period from 2020 to 2022 is strategically chosen to encompass the market fluctuations due to the COVID-19 pandemic.This timeframe allows for the analysis of assets' performance through significant economic disruptions, providing insights into their resilience and potential for recovery.

### Why slecting three years?
Span of three years offers a balance between capturing recent market behaviors and ensuring enough data for meaningful analysis and visualization.The inclusion of this volatile period is crucial for optimizing a portfolio that can withstand and capitalize on market upheavals, making the analysis more relevant for current and future investing environments.
```{r}
asset_prices <- list()
for(asset in my_assets) {
  getSymbols(asset, from = "2020-01-01", to = "2022-12-31", auto.assign = TRUE)
  asset_prices[[asset]] <- Cl(get(asset))
}
combined_prices <- do.call(merge, asset_prices)
combined_prices <- na.omit(combined_prices)
``` 

### Calculating and visualizing daily returns
Combining and cleaning the asset price data to ensure a consistent and complete dataset for analysis.
Daily returns are calculated to understand the assets' day-to-day performance, crucial for portfolio optimization.
```{r}
daily_returns <- ROC(combined_prices, type = "discrete")
daily_returns <- na.omit(daily_returns)
myRetData <- daily_returns
```


## Part 1(d): Portfolio Optimization Using Genetic Algorithm
### Defining a fitness function to maximize the portfolio's Sharpe Ratio, balancing risk and return
- The Sharpe Ratio is chosen as it is a widely used measure for calculating risk-adjusted return, enhancing portfolio performance.

```{r}
fitness_function_alpha <- function(weights, alpha=0.5) {
  normalizedWeights <- weights / sum(weights)
  portfolioReturn <- sum(colMeans(myRetData, na.rm = TRUE) * normalizedWeights) * 252
  portfolioRisk <- sqrt(t(as.matrix(normalizedWeights)) %*% cov(myRetData) %*% as.matrix(normalizedWeights)) * sqrt(252)
  SharpeRatio <- portfolioReturn / portfolioRisk
  return(SharpeRatio) # The goal is to maximize the Sharpe Ratio
}
```

## Running the genetic algorithm to find optimal portfolio weights
- Configuring and running the genetic algorithm with specified parameters to find the optimal asset weights
ga_result <- ga(type = "real-valued",
                fitness = function(weights) fitness_function_alpha(weights, alpha=0.5),
                lower = rep(0, length(my_assets)),
                upper = rep(1, length(my_assets)),
                popSize = 50,
                maxiter = 100)

optimal_weights <- ga_result@solution
normalized_optimal_weights <- optimal_weights / sum(optimal_weights)

print(optimal_weights)

## Detailed Evaluation for Future Performance
## Splitting the dataset into training and testing sets for a fair comparison
split_date <- as.Date("2022-01-01")
training_data <- daily_returns[index(daily_returns) < split_date]
testing_data <- daily_returns[index(daily_returns) >= split_date]

## Re-optimizing the portfolio using only the training data
ga_result_training <- ga(type = "real-valued",
                         fitness = function(weights) fitness_function_alpha(weights, alpha=0.5),
                         lower = rep(0, length(my_assets)),
                         upper = rep(1, length(my_assets)),
                         popSize = 50,
                         maxiter = 100,
                         suggestions = normalized_optimal_weights) # Suggestion based on full data optimization

optimal_weights_training <- ga_result_training@solution
normalized_optimal_weights_training <- optimal_weights_training / sum(optimal_weights_training)

## Comparing with Other Portfolios
## Creating a balanced portfolio for comparison
balanced_weights <- rep(1 / length(my_assets), length(my_assets))

## Generating several random portfolios for a broader comparison
set.seed(123) # Ensuring reproducibility
random_weights_list <- replicate(100, runif(length(my_assets)))
random_weights_list <- apply(random_weights_list, 2, function(x) x / sum(x))

## Define the updated calculate_performance function
calculate_performance <- function(weights, returns) {
  # Ensure weights are a numeric vector
  weights_vector <- as.numeric(weights)
  
  # Convert returns to an xts object if not already one, ensuring compatibility
  if(!is.xts(returns)) {
    returns <- as.xts(returns, order.by=index(returns))
  }
  
  # Calculate portfolio returns using the provided weights
  portfolio_returns <- Return.portfolio(R = returns, weights = weights_vector, rebalance_on = "years")
  
  # Calculate annualized return
  annualized_return <- annualReturn(portfolio_returns, scale = 252)
  
  # Calculate annualized risk
  annualized_risk <- sd(portfolio_returns) * sqrt(252)
  
  # Calculate Sharpe Ratio
  sharpe_ratio <- SharpeRatio.annualized(portfolio_returns, Rf = 0, scale = 252)
  
  # Return the calculated metrics
  return(c(annualized_return = as.numeric(annualized_return), 
           annualized_risk = annualized_risk, 
           sharpe_ratio = as.numeric(sharpe_ratio)))
}